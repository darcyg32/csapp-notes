#### Memory as Bytes
- Smallest addressable unit = 1 byte (8 bits).
- A program sees memory as a huge virtual address space (a conceptual byte array).
- Each byte has a unique a virtual address.
- Actual physical memory = mix of DRAM, flash, disk, hardware, OS management.
#### Program Objects
- Compiler + runtime partition memory into sections for code, data, stack, heap, etc.
- A pointer in C stores a virtual address of the first byte of an object.
- C compiler tracks types, but machine code has no type information. Everything becomes bytes.

---
### 2.1.1 - Hexadecimal Notation
- Hex = base 16, digits 0-9, A-F.
- One hex digit = 4 bits. Easy conversion to/from binary.
- C hex constants start with `Ox`.
- Example conversion:
	- Hex --> bin: Expand each digit.
	- Bin --> hex: Group bits into 4's.

---
### 2.1.2 - Data Sizes
#### Word Size
- Determines pointer size --> Determines max virtual address space:
	- 32-bit --> 4 GB.
	- 64-bit --> 16 EB.
- Programs can be compiled as 32 bit (-m32) or 64-bit (-m64).
#### C Data Sizes
- Varies by platform (32-bit vs 64-bit)
- Typical:
	- `char` = 1 byte. 
	- `short` = 2 bytes. 
	- `int` = 4 bytes. 
	- `long` = 4 bytes (32-bit) or 8 bytes (64-bit). 
	- `float` = 4 bytes.
	- `double` = 8 bytes.
	- pointers = word size.

---
### 2.1.3 - Addressing & Byte Ordering
#### Addressing
- Multi-byte objects stored in contiguous bytes.
- Address = lowest byte address.
#### Endianness
- **Little-endian**: Least significant byte stored first.
- **Big-endian**: Most significant byte stored first.
- Matters for:
	- Networking protocols.
	- Inspecting machine code.
	- Type punning (casts, unions).
#### Example
- `0x01234567` stored in memory:
	- Little-endian: `67 45 23 01`
	- Big-endian: `01 23 45 67`

---
### 2.1.4 - Representing Strings
- C strings = char array terminated by 0 (null byte).
- ASCII --> portable across architectures.
- `"12345"` stored as `31 32 33 34 35 00`.

---
### 2.1.5 - Representing Code
- Machine code = just bytes.
- Same C code compiles to different byte sequences on:
	- Different ISAs.
	- Different OSes.
- Binary code is not portable.

---
### 2.1.6 - Introduction to Boolean Algebra
- Boolean values: 0, 1.
- Operations:
	- `~` NOT
	- `&` AND
	- `|` OR
	- `^` XOR
- Bitwise ops can apply elementwise to bit vectors.
- Sets can be represented as bit vectors.

---
### 2.1.7 - Bit-Level Operations in C
- C provides bitwise operations for integer types (see above).
- Common strategy:
	- Convert hex --> binary --> operate --> convert back.

---
### 2.1.8 - Logical Operations in C
- **Operators**: `!` (not), `&&` (and), `||` (or).
- **Semantics**:
	- Treat 0 as false, nonzero as true.
	- Result is either 1 (true) or 0 (false).
- **Short-circuiting**: `&&` and `||` do not evaluate the right-hand operand if the result is already known.
	- Example `a && 5/a` avoids divide-by-zero is `a` is 0.
- **Distinction from bitwise**: `&`, `|`, `^`, `~` operate bitwise; `&&`, `||`, `!` operate on boolean truth values (0/1).
	- Bitwise $\neq$ logical, except when operands are 0 or 1.
- **Examples**:
	- `!0x41` → `0`
	- `!0x00` → `1`
	- `0x69 && 0x55` → `1`
	- `0x69 | 0x55` (bitwise) → `0x7D`

---
### 2.1.9 - Shift Operations in C
- Left shift: `x << k`
	- Shifts bits left by `k`, low-order `k` bits filled with `0`.
	- Equivalent to multiplication by `2^k` for unsigned when no overflow.
- Right shift: `x >> k`. Two forms (machine-dependent for signed)
	- **Logical right shift**: Fills leftmost bits with `0` (used for unsigned).
	- **Arithmetic right shift**: Fills leftmost bits with the sign bit (replicates sign). Used for signed on most platforms.
- Shift amount: Must be in range `0..w-1` (where `w` is bit-width).
- Associativity: `x << j << k` = `(x << j) << k`.
- Examples (8-bit):
	- `01100011 << 4` = `00110000`
	- `10010101 >> 4` (logical) = `00001001`
	- `10010101 >> 4` (arithmetic) = `11111001`