#### Core Idea
- Computer integers are fixed-width. Operations overflow, wrap, and behave *modulo* 2^w. This means:
	- `x + y` can look negative.
	- `x < y` can disagree with `(x - y) < 0`.
	- Unsigned and signed arithmetic differ only in *interpretation* of the same bit patterns.

---
### 2.3.1 - Unsigned Addition
- Let $0\leq x$, $y < 2^x$.
- Unsigned addition is `x +u_w y = (x + y) mod 2^w`
**Two Cases**:
- Normal: $x + y < 2^w$ --> result = $x + y$
- Overflow: $x + y \ge 2^w$ --> result = $x + y - 2^w$ (wrap-around)
**Example**:
```C
x = 9; // = 1001
y = 12; // = 1100
x + y = 21; // = 10101
truncate to 4 bits --> 5 // 0101
```

**Detecting Overflow**
- Given `s = x +u_w y`, overflow â‡” `s < x (or equivalently, s < y)`.
	- Because unsigned wrap-around produces a "small" number.

**Unsigned Additive Inverse**
- Every unsigned number has an additive inverse under modular addition:
```
-u_w x = 
	0         if x = 0
	2^w - x   if x > 0
```
- Because $(x + (2^w - x)) \mod 2^w = 0$

---
### 2.3.2 - Two's Complement Addition
- Same hardware instruction as unsigned addition, only the interpretation differs.
- For signed integers:
`x +t_w y = (x + y), truncated to w bits and interpreted as two's complement`

**Three Cases**:
- **Normal**: $-2^{(w-1)} \le x + y < 2^{(w-1)}$ --> no overflow
- **Positive Overflow**: $x + y \ge 2^{(w-1)}$ --> result = $x + y - 2^w$
- **Negative Overflow**: $x + y < -2^{(w-1)}$ --> result = $x + y + 2^w$

**Detecting Overflow**
For `s = x +t_w y`:
- **Positive Overflow** when: $x > 0$ AND $y > 0$ AND $s \le$ 0.
- **Negative Overflow** when: $x < 0$ AND $y < 0$ AND $s \ge 0$.
Signs must "agree" for overflow to be possible.

---
### 2.3.3 - Two's Complement Negation
Every number except `TMin` has a negation.
```
-t_w x =
	TMin_w    if x = TMin_w (it's its own inverse)
	-x        otherwise
```
Because `TMin` cannot be represented as a positive integer in w bits.

---
### 2.3.4 - Unsigned Multiplication
Unsigned result is modulo $2^w$:
`x *u_w y = (x * y) mod 2^w`
- Equivalent to taking the *low w bits* of the full 2w-bit product.

---
### 2.3.5 - Two's Complement Multiplication
Similarly:
`x *t_w y = U2T_w((x * y) mod 2^w)`

> The bit-level behaviour of unsigned and two's complement multiplication is identical. The difference is only in interpretation.

---
### 2.3.6 - Multiplying by Constants (Optimization)
**Left Shift = Multiply by $2^k$**
- Appending *k* zero bits:
	- `x << k = x * 2^k    (mod 2^w)`
- This is true for both unsigned and signed

**Compilers Optimize `x * K`**
Use:
- Sums of shifted values:
	- E.g. `14 = 8 + 4 + 2` --> `x*14 = (x<<3) + (x<<2) + (x<<1)`
- Or difference of shifts:
	- E.g. `14 = 16 - 2` --> `x*14 = (x<<4) - (x<<1)`
This avoids expensive multiply instructions.

---
### 2.3.7 - Dividing by Powers of 2
- Hardware division is slow (~30+ cycles).
- Dividing by powers of two can be done with right shifts.
	- Unsigned: Logical right shift.
	- Two's complement: arithmetic right shift, with optional bias for correct rounding.

#### Unsigned Division by 2^k 
- Logical right shift (`>>`) is used.
- Always performs: `x >> k == floor(x / 2^k)`
- Correct for unsigned because logical shifts insert 0s.

#### Two's Complement Division
- Arithmetic right shift (`>>`) preserves the sign bit.
- It computes: `x >> k == floor(x / 2^k)`
- This is correct for $x\ge 0$, but incorrect for $x < 0$, because integer division must round toward zero, not down.

- To correct this: `(x < 0 ? x + (1 << k) - 1 : x) >> k`
	- The added bias `(2^k - 1)` fixes rounding for negative values.

---
### 2.3.8 - Final Thoughts on Integer Arithmetic
**Core**:
- All integer arithmetic is modular arithmetic modulo 2^w.
- Overflow does *not* signal errors. It silently wraps.
- Unsigned and two's-complement arithmetic shares the same hardware operations. Only interpretation differs.

**Key Takeaways**:
- Two's complement encoding allows:
	- Same adder/multiplier hardware.
	- Uniform wraparound behaviour.
	- Clean sign/zero extension rules.
- C's rules around unsigned types cause many subtle bugs (promotion rules, comparisons, mixing signed/unsigned).
- Integer constants or library functions can implicitly convert values to unsigned --> surprising behaviour.
- Correct handling of shifts/division is important for:
	- Performance optimizations.
	- Bit-level reasoning.
	- Avoiding rounding mistakes.
	- Writing portable, correct code.