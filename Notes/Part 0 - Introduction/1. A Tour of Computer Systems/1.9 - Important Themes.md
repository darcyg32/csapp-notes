### Core Idea
- A computer system is both hardware and software, working together to run applications efficiently, reliably, and securely.
- Several key principles appear throughout computer systems: Amdahl's Law, Concurrency & Parallelism, and Abstraction.

---
### 1.9.1 Amdahl's Kaw
##### Concept
- Improving one part of a system gives diminishing returns if that part isn't a large portion of total execution time.
##### Formula
$T_{new}=(1-\alpha)T_{old}+\frac{\alpha T_{old}}{k}$
$S=\frac{T_{old}}{T_{new}}=\frac{1}{(1-\alpha)+\alpha/k}$
Where:
- $\alpha$: Fraction of total time affected by the improvement.
- $k$: Speedup factor for that part.
##### Examples
- If 60% of time ($\alpha=0.6$) is sped up 3x --> total speedup = 1.67x.
- If that 60% becomes infinitely fast --> max total speedup = 2.5x.
##### Key Takeaways
- Overall speedup depends on how much of the system benefits.
- To make systems significantly faster, you must optimize large fractions of the workload.
- The principle applies to any process (not just software).

---
### Concurrency and Parallelism
##### Definitions:
- **Concurrency**: Multiple activities happening simultaneously (real or simulated).
- **Parallelism**: Using concurrency to run faster.
Parallelism exists at three main levels:
##### 1. Thread-Level Parallelism (TLP)
- **Concurrency:** Multiple processes or threads run at once.
- **Uniprocessor Systems**: Simulate concurrency by rapid task switching.
- **Multiprocessor Systems**: Multiple CPUs or cores execute threads truly in parallel.
- **Multi-core Processors**: Multiple cores on one chip; each with private L1/L2 caches.
- **Hyperthreading (Simultaneous Multithreading):**
	- One core runs multiple threads by duplicating some CPU components.
	- E.g., Intel Core i7 --> 4 cores x 2 threads = 8 threads total.
- Benefits:
	1.  Enables true multitasking (multiple users/processes).
	2. Speeds up programs designed for parallel threads.
- Requires software that can exploit parallelism effectively.

##### 2. Instruction-Level Parallelism (ILP)
- Modern CPUs can execute multiple instructions per cycle.
- **Pipelining**: Breaks instruction execution into stages that run in parallel.
- **Superscalar processors**: Execute >1 instruction per clock using multiple pipelines.
- Programmers can improve ILP by writing code that allows the compiler to reorder and parallelize instructions.

##### 3. Single-Instruction, Multiple-Data (SIMD)
- A single instruction performs operations on multiple data items at once.
- Example: adding 8 pairs of floats in one CPU instruction.
- Common in image, sound, and video processing.
- Exposed via vector data types or special SIMD intrinsics.

#### Key Takeaways
- Performance grows by doing more things at once.
- Hardware supports multiple layers of parallelism:
	- Threads --> Instructions --> Data.
- Wiring parallel-friendly software is essential for modern CPUs.

---
### 1.9.3 - The Importance of Abstractions
##### Concept
- Abstraction hides low-level details, allowing complex systems to be understood and used easily.
- Programmers use APIs, classes, and function prototypes to interact with code without knowing implementation details.

##### System Abstraction Layers

| Abstraction                            | Represents                          | Purpose                                                                                                        |
| -------------------------------------- | ----------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| **Instruction Set Architecture (ISA)** | Abstract view of processor          | Lets programs behave as if each instruction executes sequentially, even though hardware runs many in parallel. |
| **Files**                              | Abstract view of I/O devices        | Unified way to access data (disk, keyboard, network).                                                          |
| **Virtual Memory**                     | Abstract view of memory             | Each program sees its own private address space.                                                               |
| **Processes**                          | Abstract view of CPU execution      | Makes each running program seem independent.                                                                   |
| **Virtual Machine**                    | Abstract view of an entire computer | Lets one system run programs from other OSes (Windows, Linux, etc).                                            |

##### Key Takeaways
- Abstractions allow:
	- **Hardware Independence**: Same program runs on different CPUs.
	- **Isolation**: Each process runs safely and predictably.
	- **Simplified Design**: Complex systems become modular.
- Modern systems rely heavily on layered abstractions for efficiency and scalability.

---

![[Pasted image 20251112132329.png]]
![[Pasted image 20251112132333.png]]
![[Pasted image 20251112132340.png]]